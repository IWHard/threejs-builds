<!DOCTYPE html>
<html>
  <body>
    <canvas width="570" height="570" id="my_Canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
      var gl, program;
      var numTireIndices, numPlaneIndices;

      // === Camera orbit variables ===
      var orbitRadius = 12.0;
      var cameraAngleY = 0.0;
      var cameraAngleX = 0.3;
      var cameraPosition = vec3.create();
      var targetPosition = vec3.fromValues(0, 0, 0);
      var upVector = vec3.fromValues(0, 1, 0);
      var sensitivity = 0.005;

      // === Tire orbit variables ===
      var cylOrbitRadius = 5.0; 
      var tireRadius = 0.6;  
      var cylOrbitSpeed = 1.0;  
      var cylOrbitAngle = 0.0;
      var tireSpinAngle = 0.0;

      // === Mouse control ===
      var isDragging = false;
      var lastMouseX = 0;
      var lastMouseY = 0;

      // === Matrices ===
      var modelMatrix = mat4.create();
      var viewMatrix = mat4.create();
      var projectionMatrix = mat4.create();
      var modelViewProjectionMatrix = mat4.create();
      var u_modelViewProjectionMatrix;

      var buffers = {};

      main();

      function main() {
        var canvas = document.getElementById("my_Canvas");
        gl = canvas.getContext("webgl");
        if (!gl) { alert("WebGL not supported"); return; }
        gl.viewport(0, 0, canvas.width, canvas.height);

        // === Geometry ===
        var { vertices: tireVerts, indices: tireIndices } = createTorusGeometry(tireRadius, 0.2, 40, 20);
        numTireIndices = tireIndices.length;
        var { vertices: planeVerts, indices: planeIndices } = createPlaneGeometry(40);
        numPlaneIndices = planeIndices.length;

        // === Shaders ===
        var vsSource = `
          attribute vec4 a_position;
          varying vec3 v_position;
          uniform mat4 u_modelViewProjectionMatrix;
          void main() {
            v_position = a_position.xyz;
            gl_Position = u_modelViewProjectionMatrix * a_position;
          }
        `;
        var fsSource = `
          precision mediump float;
          varying vec3 v_position;
          void main() {
            float angle = atan(v_position.z, v_position.x);
            float stripe = step(0.0, sin(angle * 10.0)); // stripes around tire
            vec3 color1 = vec3(0.1, 0.1, 0.1);
            vec3 color2 = vec3(0.9, 0.2, 0.2);
            vec3 color = mix(color1, color2, stripe);
            gl_FragColor = vec4(color, 1.0);
          }
        `;
        var vs = createShader(gl.VERTEX_SHADER, vsSource);
        var fs = createShader(gl.FRAGMENT_SHADER, fsSource);
        program = createProgram(vs, fs);
        gl.useProgram(program);

        // === Buffers ===
        setupBuffer("tire", tireVerts, tireIndices);
        setupBuffer("plane", planeVerts, planeIndices);

        // === Uniforms ===
        u_modelViewProjectionMatrix = gl.getUniformLocation(program, "u_modelViewProjectionMatrix");

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // === Mouse ===
        canvas.addEventListener("mousedown", e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
        canvas.addEventListener("mouseup", () => isDragging = false);
        canvas.addEventListener("mousemove", e => {
          if (!isDragging) return;
          var dx = e.clientX - lastMouseX;
          var dy = e.clientY - lastMouseY;
          cameraAngleY += dx * sensitivity;
          cameraAngleX -= dy * sensitivity;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        });

        requestAnimationFrame(render);
      }

      function render(now) {
        now *= 0.001;
        cylOrbitAngle = now * cylOrbitSpeed;
        tireSpinAngle = (cylOrbitAngle * cylOrbitRadius) / tireRadius; // rolling physics

        // === Camera ===
        cameraAngleX = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, cameraAngleX));
        var camX = orbitRadius * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
        var camY = orbitRadius * Math.sin(cameraAngleX);
        var camZ = orbitRadius * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
        vec3.set(cameraPosition, camX, camY, camZ);

        mat4.lookAt(viewMatrix, cameraPosition, targetPosition, upVector);
        mat4.perspective(projectionMatrix, Math.PI/4, gl.canvas.width/gl.canvas.height, 0.1, 100);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // === Draw plane ===
        mat4.identity(modelMatrix);
        mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);
        mat4.multiply(modelViewProjectionMatrix, modelViewProjectionMatrix, modelMatrix);
        gl.uniformMatrix4fv(u_modelViewProjectionMatrix, false, modelViewProjectionMatrix);
        bindBuffer("plane");
        gl.drawElements(gl.TRIANGLES, numPlaneIndices, gl.UNSIGNED_SHORT, 0);

        // === Draw tire ===
        var x = cylOrbitRadius * Math.cos(cylOrbitAngle);
        var z = cylOrbitRadius * Math.sin(cylOrbitAngle);

        mat4.identity(modelMatrix);
        mat4.translate(modelMatrix, modelMatrix, [x, tireRadius, z]);
        mat4.rotateY(modelMatrix, modelMatrix, -cylOrbitAngle + Math.PI);
        mat4.rotateZ(modelMatrix, modelMatrix, Math.PI / 2);
        mat4.rotateY(modelMatrix, modelMatrix, -tireSpinAngle);
        

        mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);
        mat4.multiply(modelViewProjectionMatrix, modelViewProjectionMatrix, modelMatrix);

        gl.uniformMatrix4fv(u_modelViewProjectionMatrix, false, modelViewProjectionMatrix);
        bindBuffer("tire");
        gl.drawElements(gl.TRIANGLES, numTireIndices, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(render);

      }

      // === Helpers ===
      function setupBuffer(name, vertices, indices) {
        var vao = {};
        vao.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vao.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        vao.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vao.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        buffers[name] = vao;
      }
      function bindBuffer(name) {
        var vao = buffers[name];
        var posAttrib = gl.getAttribLocation(program, "a_position");
        gl.bindBuffer(gl.ARRAY_BUFFER, vao.positionBuffer);
        gl.enableVertexAttribArray(posAttrib);
        gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vao.indexBuffer);
      }

      function createShader(type, source) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }
      function createProgram(vs, fs) {
        var program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Program link error:", gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }

      // === Geometry ===
      function createTorusGeometry(outerRadius, tubeRadius, radialSegments, tubularSegments) {
        var vertices = [];
        var indices = [];
        for (var j = 0; j <= tubularSegments; j++) {
          for (var i = 0; i <= radialSegments; i++) {
            var u = i / radialSegments * Math.PI * 2;
            var v = j / tubularSegments * Math.PI * 2;

            var x = (outerRadius + tubeRadius * Math.cos(v)) * Math.cos(u);
            var y = tubeRadius * Math.sin(v);
            var z = (outerRadius + tubeRadius * Math.cos(v)) * Math.sin(u);

            vertices.push(x, y, z);
          }
        }
        for (var j = 1; j <= tubularSegments; j++) {
          for (var i = 1; i <= radialSegments; i++) {
            var a = (radialSegments+1) * j + i - 1;
            var b = (radialSegments+1) * (j-1) + i - 1;
            var c = (radialSegments+1) * (j-1) + i;
            var d = (radialSegments+1) * j + i;
            indices.push(a,b,d);
            indices.push(b,c,d);
          }
        }
        return { vertices, indices };
      }

      function createPlaneGeometry(size) {
        var half = size / 2;
        var vertices = [
          -half, -0.2, -half,
           half, -0.2, -half,
           half, -0.2,  half,
          -half, -0.2,  half,
        ];
        var indices = [0,1,2, 0,2,3];
        return { vertices, indices };
      }
    </script>
  </body>
</html>
