<html lang="en"><head>
  <meta charset="UTF-8">
    <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png">
    <meta name="apple-mobile-web-app-title" content="CodePen">
    <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg" color="#111">
    <script src="https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js"></script>
  <title>Ordenamiento</title>
    <link rel="canonical" href="https://codepen.io/ch3coohlink/pen/RwWddYM">
<style>
@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
body {
  margin: 0;
}
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>
  
</head>

<body translate="no">
  <canvas id="canvas" width="797" height="277"></canvas>
  <button id="nextSortStep" style="position: absolute; top: 100px; right: 100px; z-index: 20;">
    Siguiente Paso
  </button>
<!-- vertex shader -->
<script id="vertex-shader-3d" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 color;
attribute mat4 matrix;
uniform mat4 projection;
uniform mat4 view;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = projection * view * matrix * a_position;

  // Pass the vertex color to the fragment shader.
  v_color = color;
}
</script>
<!-- fragment shader -->
<script id="fragment-shader-3d" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

void main() {
  gl_FragColor = v_color;
}
</script><!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
  
    <script id="rendered-js">
// WebGL - Instanced Drawing
// from https://webglfundamentals.org/webgl/webgl-instanced-drawing-projection-view.html


'use strict';

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector('#canvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    return;
  }

  const ext = gl.getExtension('ANGLE_instanced_arrays');
  if (!ext) {
    return alert('need ANGLE_instanced_arrays'); // eslint-disable-line
  }

  function bubbleSortStep(arr) {
    let swapped = false;
    let n = arr.length;
    
    // This is a simple single-pass of the bubble sort algorithm
    for (let i = 0; i < n - 1; i++) {
        // Compare current figure scale with the next figure scale
        if (arr[i].scale > arr[i + 1].scale) {
            // Swap the figure objects (swaps scale, color, and matrix references)
            [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
            swapped = true;
        }
    }
    return swapped; // Return true if a swap happened
  }

  function generateRandomScales(count, min, max) {
      const s = [];
      for (let i = 0; i < count; i++) {
          // Math.random() gives [0, 1). Scale and shift to get [min, max).
          const scale = Math.random() * (max - min) + min;
          // Use two decimal places for clean values
          s.push(parseFloat(scale.toFixed(2))); 
      }
      return s;
  }

  // setup GLSL programs
  // compiles shaders, links program
  const program = webglUtils.createProgramFromScripts(
  gl, ['vertex-shader-3d', 'fragment-shader-3d']);

  const positionLoc = gl.getAttribLocation(program, 'a_position');
  const colorLoc = gl.getAttribLocation(program, 'color');
  const matrixLoc = gl.getAttribLocation(program, 'matrix');
  const projectionLoc = gl.getUniformLocation(program, 'projection');
  const viewLoc = gl.getUniformLocation(program, 'view');

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.1, 0.4,
  -0.1, -0.4,
  0.1, -0.4,
  0.1, -0.4,
  -0.1, 0.4,
  0.1, 0.4,
  0.4, -0.1,
  -0.4, -0.1,
  -0.4, 0.1,
  -0.4, 0.1,
  0.4, -0.1,
  0.4, 0.1]),
  gl.STATIC_DRAW);
  const numVertices = 12;

  // setup matrixes, one per instance
   const numInstances = 5;
  const scales = generateRandomScales(numInstances, 0.3, 1.2);
  const colors = [
    [1, 0, 0, 1], // red
    [0, 1, 0, 1], // green
    [0, 0, 1, 1], // blue
    [1, 0, 1, 1], // magenta
    [0, 1, 1, 1]  // cyan
];
 

  // make a typed array with one view per matrix
  const matrixData = new Float32Array(numInstances * 16);
  const matrices = [];
  for (let i = 0; i < numInstances; ++i) {
    const byteOffsetToMatrix = i * 16 * 4;
    const numFloatsForView = 16;
    matrices.push(new Float32Array(
    matrixData.buffer,
    byteOffsetToMatrix,
    numFloatsForView));
  }

  const figures = [];
  for (let i = 0; i < numInstances; ++i) {
      figures.push({
          scale: scales[i],
          color: colors[i],
          matrix: matrices[i],
          originalIndex: i, // Keep track of the original color/matrix slot
      });
  }

  const matrixBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
  // just allocate the buffer
  gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);

  // setup colors, one per instance
  const colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array(colors.flat()),
  gl.STATIC_DRAW);

  let isSorted = false;
  const sortButton = document.querySelector('#nextSortStep');

  sortButton.addEventListener('click', () => {
      if (!isSorted) {
          isSorted = !bubbleSortStep(figures);
          if (isSorted) {
              sortButton.textContent = 'Listo!';
              sortButton.disabled = true;
          }
      }
  });

  function render(time) {
    time *= 0.005; // seconds

    webglUtils.resizeCanvasToDisplaySize(gl.canvas);

    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    gl.useProgram(program);

    // set the view and projection matrices since
    // they are shared by all instances
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    gl.uniformMatrix4fv(projectionLoc, false,
    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
    gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    
    figures.forEach((figure, ndx) => {
      // 'mat' is the matrix object *within* the figure object
      const mat = figure.matrix;
      const scale = figure.scale;
      
      // The position is now determined by the figure's *current index* (ndx)
      const xPos = -0.5 + ndx * 0.25; 
      // 1. Reset matrix
      m4.identity(mat);
      m4.translate(mat, xPos, 0, 0, mat); 
      m4.zRotate(mat, time * (0.1 + 0.1 * figure.originalIndex), mat);
      m4.scale(mat, scale, scale, 1, mat);      
    });

    // upload the new matrix data
    gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);

    // set all 4 attributes for matrix
    const bytesPerMatrix = 4 * 16;
    for (let i = 0; i < 4; ++i) {
      const loc = matrixLoc + i;
      gl.enableVertexAttribArray(loc);
      // note the stride and offset
      const offset = i * 16; // 4 floats per row, 4 bytes per float
      gl.vertexAttribPointer(
      loc, // location
      4, // size (num values to pull from buffer per iteration)
      gl.FLOAT, // type of data in buffer
      false, // normalize
      bytesPerMatrix, // stride, num bytes to advance to get to next set of values
      offset // offset in buffer
      );
      // this line says this attribute only changes for each 1 instance
      ext.vertexAttribDivisorANGLE(loc, 1);
    }

    // set attribute for color
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
    // this line says this attribute only changes for each 1 instance
    ext.vertexAttribDivisorANGLE(colorLoc, 1);

    ext.drawArraysInstancedANGLE(
    gl.TRIANGLES,
    0, // offset
    numVertices, // num vertices per instance
    numInstances // num instances
    );
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}

main();
//# sourceURL=pen.js
  </script>
</body></html>