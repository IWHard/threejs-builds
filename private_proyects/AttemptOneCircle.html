<!DOCTYPE html>
<html>
  <body>
    <canvas width="570" height="570" id="my_Canvas"></canvas>
    <script>
      main();
      function main() {
        var canvas = document.getElementById("my_Canvas");
        var gl = canvas.getContext("experimental-webgl");
        if (!gl) {
          alert("WebGL not supported");
          return;
        }

        // === Datos del Cilindro ===
        var sides = 40;
        var radius = 0.3;
        var height = 0.1;
        var stepTheta = (2 * Math.PI) / sides;
        var verticesCyl = [];
        var colorsCyl = [];

        // === Cilindro hueco ===
        for (let i = 0; i < sides; i++) {
          let theta = i * stepTheta;
          let nextTheta = (i + 1) * stepTheta;
          let x1 = radius * Math.cos(theta),
            y1 = radius * Math.sin(theta);
          let x2 = radius * Math.cos(nextTheta),
            y2 = radius * Math.sin(nextTheta);

          verticesCyl.push(x1, y1, -height, x2, y2, -height, x1, y1, height);
          verticesCyl.push(x1, y1, height, x2, y2, -height, x2, y2, height);

          for (let j = 0; j < 6; j++) {
            colorsCyl.push(0.2, 0.2, 0.2);
          }
        }

        // === Punto ===
        var dotVertices = [0, 0, 0];
        var dotColors = [1, 0, 0]; // punto rojo

        var vertCode = `
          attribute vec3 position;
          attribute vec3 color;
          varying vec3 vColor;
          uniform mat4 Pmatrix;
          uniform mat4 Vmatrix;
          uniform mat4 Mmatrix;
          void main(void){
            gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position,1.0);
            vColor = color;
            gl_PointSize = 8.0;
          }`;
        var fragCode = `
          precision mediump float;
          varying vec3 vColor;
          void main(void){
            gl_FragColor = vec4(vColor, 1.0);
          }`;

        // ==== shader ====
        function compileShader(type, src) {
          var s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
            console.error(gl.getShaderInfoLog(s));
          return s;
        }
   
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, compileShader(gl.VERTEX_SHADER, vertCode));
        gl.attachShader(shaderProgram, compileShader(gl.FRAGMENT_SHADER, fragCode));
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);

        // =========== Buffers ==============
        var vertex_bufferCyl = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesCyl), gl.STATIC_DRAW);

        var color_bufferCyl = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorsCyl), gl.STATIC_DRAW);

        var vertex_bufferDot = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferDot);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dotVertices), gl.STATIC_DRAW);

        var color_bufferDot = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferDot);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dotColors), gl.STATIC_DRAW);

        var position = gl.getAttribLocation(shaderProgram, "position");
        var color = gl.getAttribLocation(shaderProgram, "color");
        var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
        var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
        var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

        function ortho(left, right, bottom, top, near, far) {
          return new Float32Array([
            2 / (right - left), 0, 0, 0,
            0, 2 / (top - bottom), 0, 0,
            0, 0, -2 / (far - near), 0,
            -(right + left) / (right - left),
            -(top + bottom) / (top - bottom),
            -(far + near) / (far - near),
            1,
          ]);
        }
        var proj_matrix = ortho(-3, 3, -3, 3, -10, 10);
        var view_matrix = identityMatrix();

        var time_old = 0;
        var angleOrbit = 0;
        var angleSpin = 0;

        // === Animacion ====
        function animate(time) {
          var dt = time - time_old;
          time_old = time;

          gl.clearColor(1, 1, 1, 1);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.enable(gl.DEPTH_TEST);

          angleOrbit -= 0.0004 * dt; // orbit speed
          angleSpin += 0.001 * dt;  // spin speed
          var orbitRadius = 2.0;

          var x = orbitRadius * Math.cos(angleOrbit);
          var y = orbitRadius * Math.sin(angleOrbit);

          // Calculos de rotation
          var T = translateMatrix(x, y, 0);
          var Rspin = rotateZMatrix(angleSpin);
          var Rtilt = rotateXMatrix(Math.PI / 6); 
          var M = multiplyMatrices(T, multiplyMatrices(Rtilt, Rspin));

          gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
          gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(position);

          gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
          gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(color);

          gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
          gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
          gl.uniformMatrix4fv(Mmatrix, false, M);

          gl.drawArrays(gl.TRIANGLES, 0, verticesCyl.length / 3);

          gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferDot);
          gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(position);

          gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferDot);
          gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(color);

          gl.uniformMatrix4fv(Mmatrix, false, identityMatrix());
          gl.drawArrays(gl.POINTS, 0, 1);

          requestAnimationFrame(animate);
        }
        animate(0);
        
        // === Funciones de apoyo ===
        function identityMatrix() {
          return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
          ]);
        }
        function translateMatrix(x, y, z) {
          var m = identityMatrix();
          m[12] = x;
          m[13] = y;
          m[14] = z;
          return m;
        }
        function rotateZMatrix(angle) {
          var c = Math.cos(angle), s = Math.sin(angle);
          return new Float32Array([
            c, -s, 0, 0,
            s,  c, 0, 0,
            0,  0, 1, 0,
            0,  0, 0, 1
          ]);
        }
        function rotateXMatrix(angle) {
          var c = Math.cos(angle), s = Math.sin(angle);
          return new Float32Array([
            1, 0, 0, 0,
            0, c,-s, 0,
            0, s, c, 0,
            0, 0, 0, 1
          ]);
        }
        function multiplyMatrices(a, b) {
          var out = new Float32Array(16);
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
              out[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
            }
          }
          return out;
        }
      }
    </script>
  </body>
</html>
